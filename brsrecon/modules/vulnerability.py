"""
Project: BRS-RECON (Network Reconnaissance Tool)
Company: EasyProTech LLC (www.easypro.tech)
Dev: Brabus
Date: Sun 07 Sep 2025
Status: Modified
Telegram: https://t.me/EasyProTech
"""

import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from ..core.base import ScanConfig, WebModule
from ..core.utils import (
    check_tool_availability,
    run_command,
)


@dataclass
class Finding:
    """Unified vulnerability finding structure"""

    type: str  # network, web, ssl
    source: str  # nmap, nikto, sslscan, etc
    severity: str  # low, medium, high, critical
    title: str
    description: str
    port: Optional[int] = None
    url: Optional[str] = None


class VulnerabilityScanner(WebModule):
    """Vulnerability assessment and security scanning module"""

    def __init__(self, config: Optional[ScanConfig] = None):
        super().__init__("Vulnerability Scanner", config)
        self.vulnerability_db = {
            "web": ["nikto", "sqlmap", "dirb"],
            "network": ["nmap", "masscan"],
            "ssl": ["sslscan", "testssl.sh"],
        }

    def validate_requirements(
        self, include_web: bool = True, include_ssl: bool = True
    ) -> bool:
        """Check if required tools are available based on scan options"""
        required = ["nmap"]
        if include_web:
            required.append("nikto")

        all_tools = set(required) | {"sqlmap", "dirb", "sslscan", "testssl.sh"}
        tool_status = {tool: check_tool_availability(tool) for tool in all_tools}

        for tool, available in tool_status.items():
            self.logger.tool_check(tool, available)

        return all(tool_status.get(tool, False) for tool in required)

    def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """Perform vulnerability scanning"""
        scan_type = kwargs.get("scan_type", "basic")
        include_web = kwargs.get("web_scan", True)
        include_ssl = kwargs.get("ssl_scan", True)
        aggressive = kwargs.get("aggressive", False)

        results = {
            "target": target,
            "scan_type": scan_type,
            "vulnerabilities": [],
            "web_vulnerabilities": [],
            "ssl_issues": [],
            "nmap_vulns": [],
            "scan_summary": {},
        }

        if scan_type == "basic":
            results.update(self._basic_vuln_scan(target, include_web, include_ssl))
        elif scan_type == "comprehensive":
            results.update(
                self._comprehensive_vuln_scan(
                    target, include_web, include_ssl, aggressive
                )
            )
        elif scan_type == "web_only":
            results.update(self._web_vulnerability_scan(target, aggressive))
        else:
            raise ValueError(f"Unknown scan type: {scan_type}")

        return results

    def _basic_vuln_scan(
        self, target: str, include_web: bool, include_ssl: bool
    ) -> Dict[str, Any]:
        """Perform parallel basic vulnerability scan"""
        self.logger.info(f"Starting basic vulnerability scan on {target}")

        results = {"nmap_vulns": [], "web_vulnerabilities": [], "ssl_issues": []}
        tasks = {}

        with ThreadPoolExecutor(max_workers=3) as executor:
            # Always run nmap
            tasks[executor.submit(self._nmap_vuln_scan, target)] = "nmap"

            if include_web:
                tasks[executor.submit(self._nikto_scan, target)] = "web"

            if include_ssl:
                tasks[executor.submit(self._ssl_scan, target)] = "ssl"

            for future in as_completed(tasks):
                scan_type = tasks[future]
                try:
                    data = future.result()
                except Exception as e:
                    self.logger.debug(f"{scan_type} scan error: {e}")
                    data = []

                if scan_type == "nmap":
                    results["nmap_vulns"] = data
                elif scan_type == "web":
                    results["web_vulnerabilities"] = data
                else:
                    results["ssl_issues"] = data

        # Combine all vulnerabilities
        all_vulns = (
            results["nmap_vulns"]
            + results["web_vulnerabilities"]
            + results["ssl_issues"]
        )
        results["vulnerabilities"] = all_vulns
        results["scan_summary"] = {
            "scan_type": "basic",
            "total_vulnerabilities": len(all_vulns),
            "nmap_vulns": len(results["nmap_vulns"]),
            "web_vulns": len(results["web_vulnerabilities"]),
            "ssl_issues": len(results["ssl_issues"]),
        }

        return results

    def _comprehensive_vuln_scan(
        self, target: str, include_web: bool, include_ssl: bool, aggressive: bool
    ) -> Dict[str, Any]:
        """Perform comprehensive vulnerability scan"""
        self.logger.info(f"Starting comprehensive vulnerability scan on {target}")

        # Start with basic scan
        results = self._basic_vuln_scan(target, include_web, include_ssl)

        # Additional scans for comprehensive mode
        if include_web and aggressive:
            sql_vulns = self._sql_injection_scan(target)
            results["sql_vulnerabilities"] = sql_vulns
            results["web_vulnerabilities"].extend(sql_vulns)

        # Update summary
        all_vulns = (
            results["nmap_vulns"]
            + results["web_vulnerabilities"]
            + results["ssl_issues"]
        )
        results["vulnerabilities"] = all_vulns
        results["scan_summary"].update(
            {
                "scan_type": "comprehensive",
                "total_vulnerabilities": len(all_vulns),
                "aggressive_mode": aggressive,
            }
        )

        return results

    def _web_vulnerability_scan(self, target: str, aggressive: bool) -> Dict[str, Any]:
        """Perform web-only vulnerability scan"""
        self.logger.info(f"Starting web vulnerability scan on {target}")

        web_vulns = self._nikto_scan(target)

        if aggressive:
            sql_vulns = self._sql_injection_scan(target)
            web_vulns.extend(sql_vulns)

        return {
            "vulnerabilities": web_vulns,
            "web_vulnerabilities": web_vulns,
            "scan_summary": {
                "scan_type": "web_only",
                "total_vulnerabilities": len(web_vulns),
                "aggressive_mode": aggressive,
            },
        }

    def _nmap_vuln_scan(self, target: str) -> List[Dict[str, Any]]:
        """2-phase nmap vulnerability scan: discovery -> targeted vuln scan"""
        self.logger.info(f"Running nmap vulnerability scripts on {target}")

        ports = "80,443,22,21,25"  # Default ports

        # Phase 1: Quick port discovery
        discovery_cmd = [
            "nmap",
            "-Pn",
            "-T4",
            "--top-ports",
            "100",
            "-sS",
            "-oG",
            "-",
            target,
        ]
        disc_result = run_command(discovery_cmd, timeout=60)

        if disc_result["success"]:
            # Parse open ports from grepable output
            match = re.search(r"Ports:\s+(.*)", disc_result["stdout"])
            if match:
                open_ports = re.findall(r"(\d+)/open", match.group(1))
                if open_ports:
                    ports = ",".join(sorted(set(open_ports), key=int))
                    self.logger.debug(f"Found open ports: {ports}")

        # Phase 2: Targeted vulnerability scan
        vulns = []
        vuln_cmd = ["nmap", "-Pn", "-sV", "--script", "vuln", "-p", ports, target]
        vuln_result = run_command(vuln_cmd, timeout=180)

        if vuln_result["success"]:
            vulns.extend(self._parse_nmap_vulns(vuln_result["stdout"], "vuln"))
        else:
            self.logger.debug(f"Nmap vuln scan failed: {vuln_result['stderr']}")

        return vulns

    def _nikto_scan(self, target: str) -> List[Dict[str, Any]]:
        """Improved Nikto scan with better parsing"""
        self.logger.info(f"Running Nikto scan on {target}")

        vulns = []
        target_url = target if target.startswith("http") else f"http://{target}"

        # Use output to stdout instead of file to avoid permission issues
        cmd = [
            "nikto",
            "-h",
            target_url,
            "-output", "-",  # Output to stdout
            "-Format", "txt",
            "-Tuning", "1,2,3,4,5,6,7,8,9",  # More comprehensive tuning
            "-ask", "no",
            "-timeout", "10",
            "-maxtime", "120"  # Limit scan time
        ]
        
        try:
            result = run_command(cmd, timeout=180)
            
            if not result["success"]:
                self.logger.debug(f"Nikto scan failed: {result.get('stderr', 'Unknown error')}")
                return vulns

            # Parse all findings starting with '+'
            output_lines = result["stdout"].splitlines() if result["stdout"] else []
            
            for line in output_lines:
                line = line.strip()
                if not line.startswith("+ "):
                    continue

                # Skip header and info lines
                if any(skip in line.lower() for skip in ["target:", "start:", "end:", "server:", "retrieved"]):
                    continue

                finding_text = line[2:].strip()  # Remove '+ '
                if finding_text and len(finding_text) > 10:  # Filter out too short findings
                    # Determine severity based on keywords
                    severity = "low"
                    if any(keyword in finding_text.lower() for keyword in ["sql", "xss", "injection", "vulnerability", "exploit"]):
                        severity = "high"
                    elif any(keyword in finding_text.lower() for keyword in ["outdated", "version", "disclosure", "directory"]):
                        severity = "medium"
                    
                    vulns.append({
                        "type": "web",
                        "source": "nikto",
                        "severity": severity,
                        "title": finding_text[:100] + "..." if len(finding_text) > 100 else finding_text,
                        "description": finding_text,
                        "url": target_url
                    })

        except Exception as e:
            self.logger.debug(f"Nikto scan exception: {e}")
            
        return vulns

    def _ssl_scan(self, target: str) -> List[Dict[str, Any]]:
        """SSL/TLS vulnerability scan with both tools"""
        self.logger.info(f"Running SSL scan on {target}")

        issues = []

        # sslscan
        if check_tool_availability("sslscan"):
            cmd = ["sslscan", "--no-colour", target + ":443"]
            result = run_command(cmd, timeout=60)
            if result["success"]:
                issues.extend(self._parse_sslscan_output(result["stdout"]))

        # testssl.sh
        if check_tool_availability("testssl.sh"):
            cmd = ["testssl.sh", "--quiet", "--fast", "--warnings=off", target + ":443"]
            result = run_command(cmd, timeout=120)
            if result["success"]:
                issues.extend(self._parse_testssl_output(result["stdout"]))

        return issues

    def _sql_injection_scan(self, target: str) -> List[Dict[str, Any]]:
        """Enhanced SQL injection scan with better parameters"""
        self.logger.info(f"Running SQL injection scan on {target}")

        if not check_tool_availability("sqlmap"):
            return []

        url = target if target.startswith("http") else f"http://{target}"
        cmd = [
            "sqlmap",
            "-u",
            url,
            "--batch",
            "--level=1",
            "--risk=1",
            "--random-agent",
            "--crawl=1",
            "--forms",
            "--smart",
            "--timeout=15",
        ]

        result = run_command(cmd, timeout=600)

        if result["success"] and "is vulnerable" in result["stdout"].lower():
            return [
                {
                    "type": "web",
                    "source": "sqlmap",
                    "severity": "high",
                    "title": "SQL injection detected",
                    "description": "SQLMap indicated potential SQL injection vulnerability",
                }
            ]

        return []

    def _parse_nmap_vulns(
        self, output: str, script_category: str
    ) -> List[Dict[str, Any]]:
        """Improved nmap vulnerability parsing"""
        vulns = []
        current_vuln = None

        for raw_line in output.splitlines():
            line = raw_line.strip()

            if "VULNERABLE" in line.upper():
                title = line.split("|", 1)[-1].strip() if "|" in line else line
                current_vuln = {
                    "type": "network",
                    "source": f"nmap-{script_category}",
                    "severity": "medium",
                    "title": title,
                    "description": title,
                }
                vulns.append(current_vuln)
                continue

            # Add additional details to current vulnerability
            if current_vuln and line.startswith("|"):
                detail = line[1:].strip()
                if detail:
                    current_vuln["description"] += f"\n{detail}"

            # End of current vulnerability block
            if current_vuln and line == "":
                current_vuln = None

        return vulns

    def _parse_sslscan_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse sslscan output for SSL issues"""
        issues = []

        for line in output.splitlines():
            line = line.strip()

            if any(
                keyword in line.upper()
                for keyword in ["VULNERABLE", "WEAK", "INSECURE"]
            ):
                issues.append(
                    {
                        "type": "ssl",
                        "source": "sslscan",
                        "severity": "medium",
                        "title": line,
                        "description": line,
                    }
                )

        return issues

    def _parse_testssl_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse testssl.sh output for SSL issues"""
        issues = []

        for line in output.splitlines():
            line = line.strip()

            keywords = ["VULNERABLE", "WEAK", "INSECURE", "CRITICAL", "HIGH"]
            if any(keyword in line.upper() for keyword in keywords):
                severity = "high" if "CRITICAL" in line.upper() else "medium"
                issues.append(
                    {
                        "type": "ssl",
                        "source": "testssl",
                        "severity": severity,
                        "title": line,
                        "description": line,
                    }
                )

        return issues
